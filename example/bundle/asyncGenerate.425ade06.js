function t(t,e,n,r){Object.defineProperty(t,e,{get:n,set:r,enumerable:!0,configurable:!0})}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},r={},o=e.parcelRequire4485;null==o&&((o=function(t){if(t in n)return n[t].exports;if(t in r){var e=r[t];delete r[t];var o={id:t,exports:{}};return n[t]=o,e.call(o.exports,o,o.exports),o.exports}var s=new Error("Cannot find module '"+t+"'");throw s.code="MODULE_NOT_FOUND",s}).register=function(t,e){r[t]=e},e.parcelRequire4485=o),o.register("aBPXg",(function(e,n){t(e.exports,"MeshBVH",(()=>o("7xeSy").MeshBVH)),t(e.exports,"MeshBVHVisualizer",(()=>o("apw2b").MeshBVHVisualizer)),t(e.exports,"CENTER",(()=>o("kx6CP").CENTER)),t(e.exports,"AVERAGE",(()=>o("kx6CP").AVERAGE)),t(e.exports,"SAH",(()=>o("kx6CP").SAH)),t(e.exports,"NOT_INTERSECTED",(()=>o("kx6CP").NOT_INTERSECTED)),t(e.exports,"INTERSECTED",(()=>o("kx6CP").INTERSECTED)),t(e.exports,"CONTAINED",(()=>o("kx6CP").CONTAINED)),t(e.exports,"getBVHExtremes",(()=>o("9iHAe").getBVHExtremes)),t(e.exports,"estimateMemoryInBytes",(()=>o("9iHAe").estimateMemoryInBytes)),t(e.exports,"acceleratedRaycast",(()=>o("24OKC").acceleratedRaycast)),t(e.exports,"computeBoundsTree",(()=>o("24OKC").computeBoundsTree)),t(e.exports,"disposeBoundsTree",(()=>o("24OKC").disposeBoundsTree)),t(e.exports,"MeshBVHUniformStruct",(()=>o("64srR").MeshBVHUniformStruct)),t(e.exports,"shaderStructs",(()=>o("bqsfV").shaderStructs)),t(e.exports,"shaderIntersectFunction",(()=>o("bqsfV").shaderIntersectFunction)),t(e.exports,"FloatVertexAttributeTexture",(()=>o("bVjKl").FloatVertexAttributeTexture));o("7xeSy"),o("apw2b"),o("kx6CP"),o("9iHAe"),o("24OKC");o("64srR"),o("bqsfV"),o("bVjKl")})),o.register("7xeSy",(function(e,n){t(e.exports,"MeshBVH",(()=>S));var r=o("hGT0Q"),s=o("kx6CP"),i=o("luBM4"),a=o("e1Md5"),c=o("8QzBU"),u=o("8GBjY"),l=o("6h74R"),d=o("briuO"),f=o("a1MBZ"),p=o("2p372");const h=Symbol("skip tree generation"),x=new r.Box3,y=new r.Box3,g=new r.Matrix4,m=new c.OrientedBox,T=new c.OrientedBox,B=new r.Vector3,b=new r.Vector3,v=new r.Vector3,A=new r.Vector3,w=new r.Vector3,E=new r.Box3,I=new l.PrimitivePool((()=>new u.SeparatingAxisTriangle));class S{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),S.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:o.array.slice()}:{roots:r,index:o.array},s}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),S.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:o,roots:s}=t,i=new S(e,{...n,[h]:!0});if(i._roots=s,n.setIndex){const n=e.getIndex();if(null===n){const n=new r.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:s.CENTER,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[h]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[h]||(this._roots=i.buildPackedTree(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new r.Box3))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,r=e.attributes.position,o=r.array,i=r.offset||0;let a,c,u,l,d=3;r.isInterleavedBufferAttribute&&(d=r.data.stride);let f=0;const p=this._roots;for(let t=0,e=p.length;t<e;t++)a=p[t],c=new Uint32Array(a),u=new Uint16Array(a),l=new Float32Array(a),h(0,f),f+=a.byteLength;function h(e,r,a=!1){const f=2*e;if(u[f+15]===s.IS_LEAFNODE_FLAG){const t=c[e+6];let r=1/0,s=1/0,a=1/0,p=-1/0,h=-1/0,x=-1/0;for(let e=3*t,c=3*(t+u[f+14]);e<c;e++){const t=n[e]*d+i,c=o[t+0],u=o[t+1],l=o[t+2];c<r&&(r=c),c>p&&(p=c),u<s&&(s=u),u>h&&(h=u),l<a&&(a=l),l>x&&(x=l)}return(l[e+0]!==r||l[e+1]!==s||l[e+2]!==a||l[e+3]!==p||l[e+4]!==h||l[e+5]!==x)&&(l[e+0]=r,l[e+1]=s,l[e+2]=a,l[e+3]=p,l[e+4]=h,l[e+5]=x,!0)}{const n=e+8,o=c[e+6],s=n+r,i=o+r;let u=a,d=!1,f=!1;t?u||(d=t.has(s),f=t.has(i),u=!d&&!f):(d=!0,f=!0);const p=u||f;let x=!1;(u||d)&&(x=h(n,r,u));let y=!1;p&&(y=h(o,r,u));const g=x||y;if(g)for(let t=0;t<3;t++){const r=n+t,s=o+t,i=l[r],a=l[r+3],c=l[s],u=l[s+3];l[e+t]=i<c?i:c,l[e+t+3]=a>u?a:u}return g}}}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i,a=0){const c=2*i,u=o[c+15]===s.IS_LEAFNODE_FLAG;if(u){const e=r[i+6],s=o[c+14];t(a,u,new Float32Array(n,4*i,6),e,s)}else{const o=i+s.BYTES_PER_NODE/4,c=r[i+6],l=r[i+7];t(a,u,new Float32Array(n,4*i,6),l)||(e(o,a+1),e(c,a+1))}}(0)}raycast(t,e=r.FrontSide){const n=this._roots,o=this.geometry,s=[],i=e.isMaterial,c=Array.isArray(e),u=o.groups,l=i?e.side:e;for(let r=0,i=n.length;r<i;r++){const i=c?e[u[r].materialIndex].side:l,d=s.length;if(a.setBuffer(n[r]),a.raycast(0,o,i,t,s),a.clearBuffer(),c){const t=u[r].materialIndex;for(let e=d,n=s.length;e<n;e++)s[e].face.materialIndex=t}}return s}raycastFirst(t,e=r.FrontSide){const n=this._roots,o=this.geometry,s=e.isMaterial,i=Array.isArray(e);let c=null;const u=o.groups,l=s?e.side:e;for(let r=0,s=n.length;r<s;r++){const s=i?e[u[r].materialIndex].side:l;a.setBuffer(n[r]);const d=a.raycastFirst(0,o,s,t);a.clearBuffer(),null!=d&&(null==c||d.distance<c.distance)&&(c=d,i&&(d.face.materialIndex=u[r].materialIndex))}return c}intersectsGeometry(t,e){const n=this.geometry;let r=!1;for(const o of this._roots)if(a.setBuffer(o),r=a.intersectsGeometry(0,n,t,e),a.clearBuffer(),r)break;return r}shapecast(t,e,n){const r=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,r,o)=>{const s=3*n;return t(e,s,s+1,s+2,r,o)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=I.getPrimitive();let{boundsTraverseOrder:s,intersectsBounds:i,intersectsRange:c,intersectsTriangle:u}=t;if(c&&u){const t=c;c=(e,n,s,i,a)=>!!t(e,n,s,i,a)||f.iterateOverTriangles(e,n,r,u,s,i,o)}else c||(c=u?(t,e,n,s)=>f.iterateOverTriangles(t,e,r,u,n,s,o):(t,e,n)=>n);let l=!1,d=0;for(const t of this._roots){if(a.setBuffer(t),l=a.shapecast(0,r,i,c,s,d),a.clearBuffer(),l)break;d+=t.byteLength}return I.releasePrimitive(o),l}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const s=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;g.copy(e).invert();const u=I.getPrimitive(),l=I.getPrimitive();if(o){function t(t,n,r,d,p,h,x,y){for(let g=r,m=r+d;g<m;g++){f.setTriangle(l,3*g,a,c),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(f.setTriangle(u,3*e,s,i),u.needsUpdate=!0,o(u,l,e,g,p,h,x,y))return!0}return!1}if(r){const e=r;r=function(n,r,o,s,i,a,c,u){return!!e(n,r,o,s,i,a,c,u)||t(n,r,o,s,i,a,c,u)}}else r=t}this.getBoundingBox(y),y.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>y.intersectsBox(t),intersectsRange:(e,n,o,s,i,a)=>(x.copy(a),x.applyMatrix4(g),t.shapecast({intersectsBounds:t=>x.intersectsBox(t),intersectsRange:(t,o,a,c,u)=>r(e,n,t,o,s,i,c,u)}))});return I.releasePrimitive(u),I.releasePrimitive(l),d}intersectsBox(t,e){return m.set(t.min,t.max,e),m.needsUpdate=!0,this.shapecast({intersectsBounds:t=>m.intersectsBox(t),intersectsTriangle:t=>m.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,s=1/0){t.boundingBox||t.computeBoundingBox(),m.set(t.boundingBox.min,t.boundingBox.max,e),m.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,u=t.attributes.position,l=t.index,d=I.getPrimitive(),p=I.getPrimitive();let h=b,x=v,y=null,B=null;r&&(y=A,B=w);let E=1/0,S=null,M=null;return g.copy(e).invert(),T.matrix.copy(g),this.shapecast({boundsTraverseOrder:t=>m.distanceToBox(t),intersectsBounds:(t,e,n)=>n<E&&n<s&&(e&&(T.min.copy(t.min),T.max.copy(t.max),T.needsUpdate=!0),!0),intersectsRange:(n,r)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>T.distanceToBox(t),intersectsBounds:(t,e,n)=>n<E&&n<s,intersectsRange:(t,s)=>{for(let i=3*t,g=3*(t+s);i<g;i+=3){f.setTriangle(p,i,l,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let t=3*n,e=3*(n+r);t<e;t+=3){f.setTriangle(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(p,h,y);if(e<E&&(x.copy(h),B&&B.copy(y),E=e,S=t/3,M=i/3),e<o)return!0}}}});for(let t=0,s=l?l.count:u.count;t<s;t+=3){f.setTriangle(p,t,l,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let e=3*n,s=3*(n+r);e<s;e+=3){f.setTriangle(d,e,c,a),d.needsUpdate=!0;const n=d.distanceToTriangle(p,h,y);if(n<E&&(x.copy(h),B&&B.copy(y),E=n,S=e/3,M=t/3),n<o)return!0}}}}),I.releasePrimitive(d),I.releasePrimitive(p),E===1/0?null:(n.point?n.point.copy(x):n.point=x.clone(),n.distance=E,n.faceIndex=S,r&&(r.point?r.point.copy(B):r.point=B.clone(),r.point.applyMatrix4(g),x.applyMatrix4(g),r.distance=x.sub(r.point).length(),r.faceIndex=M),n)}closestPointToPoint(t,e={},n=0,r=1/0){const o=n*n,s=r*r;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(B.copy(t).clamp(e.min,e.max),B.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<i&&n<s,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,B);const r=t.distanceToSquared(B);return r<i&&(b.copy(B),i=r,a=n),r<o}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(b):e.point=b.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{d.arrayToBox(0,new Float32Array(e),E),t.union(E)})),t}}const M=S.prototype.raycast;S.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,r,o]=t;return M.call(this,r,e.material).forEach((t=>{(t=p.convertRaycastIntersect(t,e,n))&&o.push(t)})),o}return M.apply(this,t)};const N=S.prototype.raycastFirst;S.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,r]=t;return p.convertRaycastIntersect(N.call(this,r,e.material),e,n)}return N.apply(this,t)};const F=S.prototype.closestPointToPoint;S.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,F.apply(this,t),e&&e.copy(n.point),n.distance}return F.apply(this,t)};const D=S.prototype.closestPointToGeometry;S.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const r={},o={},s=t[1];return t[2]=r,t[3]=o,D.apply(this,t),e&&e.copy(r.point),n&&n.copy(o.point).applyMatrix4(s),r.distance}return D.apply(this,t)};const _=S.prototype.refit;S.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),_.call(this,t)}else _.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=S.prototype[t];S.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}}))})),o.register("kx6CP",(function(e,n){t(e.exports,"CENTER",(()=>r)),t(e.exports,"AVERAGE",(()=>o)),t(e.exports,"SAH",(()=>s)),t(e.exports,"NOT_INTERSECTED",(()=>i)),t(e.exports,"INTERSECTED",(()=>a)),t(e.exports,"CONTAINED",(()=>c)),t(e.exports,"TRIANGLE_INTERSECT_COST",(()=>u)),t(e.exports,"TRAVERSAL_COST",(()=>l)),t(e.exports,"BYTES_PER_NODE",(()=>d)),t(e.exports,"IS_LEAFNODE_FLAG",(()=>f)),t(e.exports,"FLOAT32_EPSILON",(()=>p));const r=0,o=1,s=2,i=0,a=1,c=2,u=1.25,l=1,d=32,f=65535,p=Math.pow(2,-24)})),o.register("luBM4",(function(e,n){t(e.exports,"buildPackedTree",(()=>h));var r=o("hGT0Q"),s=o("iXQTr"),i=o("briuO"),a=o("kx6CP");function c(t,e,n,r,o=null){let s=1/0,i=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,x=-1/0,y=-1/0;const g=null!==o;for(let r=6*e,o=6*(e+n);r<o;r+=6){const e=t[r+0],n=t[r+1],o=e-n,m=e+n;o<s&&(s=o),m>c&&(c=m),g&&e<d&&(d=e),g&&e>h&&(h=e);const T=t[r+2],B=t[r+3],b=T-B,v=T+B;b<i&&(i=b),v>u&&(u=v),g&&T<f&&(f=T),g&&T>x&&(x=T);const A=t[r+4],w=t[r+5],E=A-w,I=A+w;E<a&&(a=E),I>l&&(l=I),g&&A<p&&(p=A),g&&A>y&&(y=A)}r[0]=s,r[1]=i,r[2]=a,r[3]=c,r[4]=u,r[5]=l,g&&(o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=x,o[5]=y)}const u=32,l=(t,e)=>t.candidate-e.candidate,d=new Array(u).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),f=new Float32Array(6);function p(t,e){function n(t){b&&b(t/v)}function o(e,r,p,b=null,v=0){if(!A&&v>=g&&(A=!0,m&&(console.warn(`MeshBVH: Max depth of ${g} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),p<=T||v>=g)return n(r+p),e.offset=r,e.count=p,e;const w=function(t,e,n,r,o,s){let c=-1,p=0;if(s===a.CENTER)c=i.getLongestEdgeIndex(e),-1!==c&&(p=(e[c]+e[c+3])/2);else if(s===a.AVERAGE)c=i.getLongestEdgeIndex(t),-1!==c&&(p=function(t,e,n,r){let o=0;for(let s=e,i=e+n;s<i;s++)o+=t[6*s+2*r];return o/n}(n,r,o,c));else if(s===a.SAH){const s=i.computeSurfaceArea(t);let h=a.TRIANGLE_INTERSECT_COST*o;const x=6*r,y=6*(r+o);for(let t=0;t<3;t++){const r=e[t],g=(e[t+3]-r)/u;if(o<8){const e=[...d];e.length=o;let r=0;for(let o=x;o<y;o+=6,r++){const s=e[r];s.candidate=n[o+2*t],s.count=0;const{bounds:a,leftCacheBounds:c,rightCacheBounds:u}=s;for(let t=0;t<3;t++)u[t]=1/0,u[t+3]=-1/0,c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0;i.expandByTriangleBounds(o,n,a)}e.sort(l);let u=o;for(let t=0;t<u;t++){const n=e[t];for(;t+1<u&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),u--}for(let r=x;r<y;r+=6){const o=n[r+2*t];for(let t=0;t<u;t++){const s=e[t];o>=s.candidate?i.expandByTriangleBounds(r,n,s.rightCacheBounds):(i.expandByTriangleBounds(r,n,s.leftCacheBounds),s.count++)}}for(let n=0;n<u;n++){const r=e[n],u=r.count,l=o-r.count,d=r.leftCacheBounds,f=r.rightCacheBounds;let x=0;0!==u&&(x=i.computeSurfaceArea(d)/s);let y=0;0!==l&&(y=i.computeSurfaceArea(f)/s);const g=a.TRAVERSAL_COST+a.TRIANGLE_INTERSECT_COST*(x*u+y*l);g<h&&(c=t,h=g,p=r.candidate)}}else{for(let t=0;t<u;t++){const e=d[t];e.count=0,e.candidate=r+g+t*g;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=x;e<y;e+=6){let o=~~((n[e+2*t]-r)/g);o>=u&&(o=31);const s=d[o];s.count++,i.expandByTriangleBounds(e,n,s.bounds)}const e=d[31];i.copyBounds(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=d[t],n=d[t+1];i.unionBounds(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let l=0;for(let e=0;e<31;e++){const n=d[e],r=n.count,u=n.bounds,x=d[e+1].rightCacheBounds;0!==r&&(0===l?i.copyBounds(u,f):i.unionBounds(u,f,f)),l+=r;let y=0,g=0;0!==l&&(y=i.computeSurfaceArea(f)/s);const m=o-l;0!==m&&(g=i.computeSurfaceArea(x)/s);const T=a.TRAVERSAL_COST+a.TRIANGLE_INTERSECT_COST*(y*l+g*m);T<h&&(c=t,h=T,p=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:c,pos:p}}(e.boundingData,b,x,r,p,B);if(-1===w.axis)return n(r+p),e.offset=r,e.count=p,e;const E=function(t,e,n,r,o){let s=n,i=n+r-1;const a=o.pos,c=2*o.axis;for(;;){for(;s<=i&&e[6*s+c]<a;)s++;for(;s<=i&&e[6*i+c]>=a;)i--;if(!(s<i))return s;for(let n=0;n<3;n++){let r=t[3*s+n];t[3*s+n]=t[3*i+n],t[3*i+n]=r;let o=e[6*s+2*n+0];e[6*s+2*n+0]=e[6*i+2*n+0],e[6*i+2*n+0]=o;let a=e[6*s+2*n+1];e[6*s+2*n+1]=e[6*i+2*n+1],e[6*i+2*n+1]=a}s++,i--}}(y,x,r,p,w);if(E===r||E===r+p)n(r+p),e.offset=r,e.count=p;else{e.splitAxis=w.axis;const t=new s.MeshBVHNode,n=r,i=E-r;e.left=t,t.boundingData=new Float32Array(6),c(x,n,i,t.boundingData,h),o(t,n,i,h,v+1);const a=new s.MeshBVHNode,u=E,l=p-i;e.right=a,a.boundingData=new Float32Array(6),c(x,u,l,a.boundingData,h),o(a,u,l,h,v+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;s=n>65535?new Uint32Array(new o(4*n)):new Uint16Array(new o(2*n)),t.setIndex(new r.BufferAttribute(s,1));for(let t=0;t<n;t++)s[t]=t}}(t,e);const p=new Float32Array(6),h=new Float32Array(6),x=function(t,e){const n=t.attributes.position,r=n.array,o=t.index.array,s=o.length/3,i=new Float32Array(6*s),c=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);for(let t=0;t<s;t++){const n=3*t,s=6*t,l=o[n+0]*u+c,d=o[n+1]*u+c,f=o[n+2]*u+c;for(let t=0;t<3;t++){const n=r[l+t],o=r[d+t],c=r[f+t];let u=n;o<u&&(u=o),c<u&&(u=c);let p=n;o>p&&(p=o),c>p&&(p=c);const h=(p-u)/2,x=2*t;i[s+x+0]=u+h,i[s+x+1]=h+(Math.abs(u)+h)*a.FLOAT32_EPSILON,u<e[t]&&(e[t]=u),p>e[t+3]&&(e[t+3]=p)}}return i}(t,p),y=t.index.array,g=e.maxDepth,m=e.verbose,T=e.maxLeafTris,B=e.strategy,b=e.onProgress,v=t.index.count/3;let A=!1;const w=[],E=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const r=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<r.length-1;t++){const n=r[t],o=r[t+1];e.push({offset:n/3,count:(o-n)/3})}return e}(t);if(1===E.length){const t=E[0],e=new s.MeshBVHNode;e.boundingData=p,function(t,e,n,r){let o=1/0,s=1/0,i=1/0,a=-1/0,c=-1/0,u=-1/0;for(let r=6*e,l=6*(e+n);r<l;r+=6){const e=t[r+0];e<o&&(o=e),e>a&&(a=e);const n=t[r+2];n<s&&(s=n),n>c&&(c=n);const l=t[r+4];l<i&&(i=l),l>u&&(u=l)}r[0]=o,r[1]=s,r[2]=i,r[3]=a,r[4]=c,r[5]=u}(x,t.offset,t.count,h),o(e,t.offset,t.count,h),w.push(e)}else for(let t of E){const e=new s.MeshBVHNode;e.boundingData=new Float32Array(6),c(x,t.offset,t.count,e.boundingData,h),o(e,t.offset,t.count,h),w.push(e)}return w}function h(t,e){const n=p(t,e);let r,o,s;const i=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let d=u(e);const f=new c(a.BYTES_PER_NODE*d);r=new Float32Array(f),o=new Uint32Array(f),s=new Uint16Array(f),l(0,e),i.push(f)}function u(t){return t.count?1:1+u(t.left)+u(t.right)}function l(t,e){const n=t/4,i=t/2,c=!!e.count,u=e.boundingData;for(let t=0;t<6;t++)r[n+t]=u[t];if(c){const r=e.offset,c=e.count;return o[n+6]=r,s[i+14]=c,s[i+15]=a.IS_LEAFNODE_FLAG,t+a.BYTES_PER_NODE}{const r=e.left,s=e.right,i=e.splitAxis;let c;if(c=l(t+a.BYTES_PER_NODE,r),c/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return o[n+6]=c/4,c=l(c,s),o[n+7]=i,c}}return i}})),o.register("iXQTr",(function(e,n){t(e.exports,"MeshBVHNode",(()=>r));class r{constructor(){}}})),o.register("briuO",(function(e,n){function r(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function o(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function s(t,e){e.set(t)}function i(t,e,n){let r,o;for(let s=0;s<3;s++){const i=s+3;r=t[s],o=e[s],n[s]=r<o?r:o,r=t[i],o=e[i],n[i]=r>o?r:o}}function a(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],s=e[t+2*r+1],i=o-s,a=o+s;i<n[r]&&(n[r]=i),a>n[r+3]&&(n[r+3]=a)}}function c(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}t(e.exports,"arrayToBox",(()=>r)),t(e.exports,"getLongestEdgeIndex",(()=>o)),t(e.exports,"copyBounds",(()=>s)),t(e.exports,"unionBounds",(()=>i)),t(e.exports,"expandByTriangleBounds",(()=>a)),t(e.exports,"computeSurfaceArea",(()=>c))})),o.register("e1Md5",(function(e,n){t(e.exports,"raycast",(()=>y)),t(e.exports,"raycastFirst",(()=>g)),t(e.exports,"shapecast",(()=>m)),t(e.exports,"intersectsGeometry",(()=>T)),t(e.exports,"setBuffer",(()=>I)),t(e.exports,"clearBuffer",(()=>S));var r=o("hGT0Q"),s=o("kx6CP"),i=o("8QzBU"),a=o("8GBjY"),c=o("2p372"),u=o("a1MBZ"),l=o("briuO"),d=o("6h74R"),f=o("a0NSC");const p=new r.Box3,h=new r.Vector3,x=["x","y","z"];function y(t,e,n,r,o){let s=2*t,i=A,a=w,u=E;if(f.IS_LEAF(s,a)){const i=f.OFFSET(t,u),l=f.COUNT(s,a);c.intersectTris(e,n,r,i,l,o)}else{const s=f.LEFT_NODE(t);B(s,i,r,h)&&y(s,e,n,r,o);const a=f.RIGHT_NODE(t,u);B(a,i,r,h)&&y(a,e,n,r,o)}}function g(t,e,n,r){let o=2*t,s=A,i=w,a=E;if(f.IS_LEAF(o,i)){const s=f.OFFSET(t,a),u=f.COUNT(o,i);return c.intersectClosestTri(e,n,r,s,u)}{const o=f.SPLIT_AXIS(t,a),i=x[o],c=r.direction[i]>=0;let u,l;c?(u=f.LEFT_NODE(t),l=f.RIGHT_NODE(t,a)):(u=f.RIGHT_NODE(t,a),l=f.LEFT_NODE(t));const d=B(u,s,r,h)?g(u,e,n,r):null;if(d){const t=d.point[i];if(c?t<=s[l+o]:t>=s[l+o+3])return d}const p=B(l,s,r,h)?g(l,e,n,r):null;return d&&p?d.distance<=p.distance?d:p:d||p||null}}const m=function(){let t,e;const n=[],o=new d.PrimitivePool((()=>new r.Box3));function i(n,r,o,a,c=null,u=0,d=0){function p(t){let e=2*t,n=w,r=E;for(;!f.IS_LEAF(e,n);)e=2*(t=f.LEFT_NODE(t));return f.OFFSET(t,r)}function h(t){let e=2*t,n=w,r=E;for(;!f.IS_LEAF(e,n);)e=2*(t=f.RIGHT_NODE(t,r));return f.OFFSET(t,r)+f.COUNT(e,n)}let x=2*n,y=A,g=w,m=E;if(f.IS_LEAF(x,g)){const e=f.OFFSET(n,m),r=f.COUNT(x,g);return l.arrayToBox(f.BOUNDING_DATA_INDEX(n),y,t),a(e,r,!1,d,u+n,t)}{const x=f.LEFT_NODE(n),T=f.RIGHT_NODE(n,m);let B,b,v,A,w=x,E=T;if(c&&(v=t,A=e,l.arrayToBox(f.BOUNDING_DATA_INDEX(w),y,v),l.arrayToBox(f.BOUNDING_DATA_INDEX(E),y,A),B=c(v),b=c(A),b<B)){w=T,E=x;const t=B;B=b,b=t,v=A}v||(v=t,l.arrayToBox(f.BOUNDING_DATA_INDEX(w),y,v));const I=o(v,f.IS_LEAF(2*w,g),B,d+1,u+w);let S;if(I===s.CONTAINED){const t=p(w);S=a(t,h(w)-t,!0,d+1,u+w,v)}else S=I&&i(w,r,o,a,c,u,d+1);if(S)return!0;A=e,l.arrayToBox(f.BOUNDING_DATA_INDEX(E),y,A);const M=o(A,f.IS_LEAF(2*E,g),b,d+1,u+E);let N;if(M===s.CONTAINED){const t=p(E);N=a(t,h(E)-t,!0,d+1,u+E,A)}else N=M&&i(E,r,o,a,c,u,d+1);return!!N}}return function(...r){t=o.getPrimitive(),e=o.getPrimitive(),n.push(t,e);const s=i(...r);o.releasePrimitive(t),o.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),s}}(),T=function(){const t=new a.SeparatingAxisTriangle,e=new a.SeparatingAxisTriangle,n=new r.Matrix4,o=new i.OrientedBox,s=new i.OrientedBox;return function r(i,a,c,d,h=null){let x=2*i,y=A,g=w,m=E;null===h&&(c.boundingBox||c.computeBoundingBox(),o.set(c.boundingBox.min,c.boundingBox.max,d),h=o);if(!f.IS_LEAF(x,g)){const t=i+8,e=m[i+6];l.arrayToBox(f.BOUNDING_DATA_INDEX(t),y,p);if(h.intersectsBox(p)&&r(t,a,c,d,h))return!0;l.arrayToBox(f.BOUNDING_DATA_INDEX(e),y,p);return!!(h.intersectsBox(p)&&r(e,a,c,d,h))}{const r=a,o=r.index,p=r.attributes.position,h=c.index,T=c.attributes.position,B=f.OFFSET(i,m),b=f.COUNT(x,g);if(n.copy(d).invert(),c.boundsTree){l.arrayToBox(f.BOUNDING_DATA_INDEX(i),y,s),s.matrix.copy(n),s.needsUpdate=!0;return c.boundsTree.shapecast({intersectsBounds:t=>s.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(d),t.b.applyMatrix4(d),t.c.applyMatrix4(d),t.needsUpdate=!0;for(let n=3*B,r=3*(b+B);n<r;n+=3)if(u.setTriangle(e,n,o,p),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let r=3*B,s=b+3*B;r<s;r+=3){u.setTriangle(t,r,o,p),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,r=h.count;n<r;n+=3)if(u.setTriangle(e,n,h,T),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function B(t,e,n,r){return l.arrayToBox(t,e,p),n.intersectBox(p,r)}const b=[];let v,A,w,E;function I(t){v&&b.push(v),v=t,A=new Float32Array(t),w=new Uint16Array(t),E=new Uint32Array(t)}function S(){v=null,A=null,w=null,E=null,b.length&&I(b.pop())}})),o.register("8QzBU",(function(e,n){t(e.exports,"OrientedBox",(()=>c));var r=o("hGT0Q"),s=o("lqzhf"),i=o("8GBjY"),a=o("b6MQC");class c extends r.Box3{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new r.Matrix4,this.invMatrix=new r.Matrix4,this.points=new Array(8).fill().map((()=>new r.Vector3)),this.satAxes=new Array(3).fill().map((()=>new r.Vector3)),this.satBounds=new Array(3).fill().map((()=>new s.SeparatingAxisBounds)),this.alignedSatBounds=new Array(3).fill().map((()=>new s.SeparatingAxisBounds)),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}c.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let o=0;o<=1;o++)for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){const a=r[1*o|2*s|4*i];a.x=o?n.x:e.x,a.y=s?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const o=this.satBounds,s=this.satAxes,i=r[0];for(let t=0;t<3;t++){const e=s[t],n=o[t],a=r[1<<t];e.subVectors(i,a),n.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},c.prototype.intersectsBox=function(){const t=new s.SeparatingAxisBounds;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,s=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=s[n],i=o[n];if(t.setFromBox(r,e),i.isSeparated(t))return!1}return!0}}(),c.prototype.intersectsTriangle=function(){const t=new i.SeparatingAxisTriangle,e=new Array(3),n=new s.SeparatingAxisBounds,o=new s.SeparatingAxisBounds,a=new r.Vector3;return function(r){this.needsUpdate&&this.update(),r.isSeparatingAxisTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const s=this.satBounds,i=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const r=s[t],o=i[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=r.satBounds,u=r.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],r=u[t];if(n.setFromPoints(r,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=i[t];for(let t=0;t<4;t++){const s=u[t];if(a.crossVectors(r,s),n.setFromPoints(a,e),o.setFromPoints(a,l),n.isSeparated(o))return!1}}return!0}}(),c.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},c.prototype.distanceToPoint=function(){const t=new r.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),c.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new r.Line3)),n=new Array(12).fill().map((()=>new r.Line3)),o=new r.Vector3,s=new r.Vector3;return function(r,i=0,c=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(c||u)&&(r.getCenter(s),this.closestPointToPoint(s,o),r.closestPointToPoint(o,s),c&&c.copy(o),u&&u.copy(s)),0;const l=i*i,d=r.min,f=r.max,p=this.points;let h=1/0;for(let t=0;t<8;t++){const e=p[t];s.copy(e).clamp(d,f);const n=e.distanceToSquared(s);if(n<h&&(h=n,c&&c.copy(e),u&&u.copy(s),n<l))return Math.sqrt(n)}let x=0;for(let r=0;r<3;r++)for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){const s=(r+1)%3,i=(r+2)%3,a=1<<r|r<<s|o<<i,c=p[r<<s|o<<i],u=p[a];e[x].set(c,u);const l=t[r],h=t[s],y=t[i],g=n[x],m=g.start,T=g.end;m[l]=d[l],m[h]=r?d[h]:f[h],m[y]=o?d[y]:f[h],T[l]=f[l],T[h]=r?d[h]:f[h],T[y]=o?d[y]:f[h],x++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){s.x=t?f.x:d.x,s.y=e?f.y:d.y,s.z=n?f.z:d.z,this.closestPointToPoint(s,o);const r=s.distanceToSquared(o);if(r<h&&(h=r,c&&c.copy(o),u&&u.copy(s),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];a.closestPointsSegmentToSegment(r,e,o,s);const i=o.distanceToSquared(s);if(i<h&&(h=i,c&&c.copy(o),u&&u.copy(s),i<l))return Math.sqrt(i)}}return Math.sqrt(h)}}()})),o.register("2p372",(function(e,n){t(e.exports,"intersectTris",(()=>s)),t(e.exports,"intersectClosestTri",(()=>i)),t(e.exports,"convertRaycastIntersect",(()=>a));var r=o("1AcK3");function s(t,e,n,o,s,i){for(let a=o,c=o+s;a<c;a++)r.intersectTri(t,e,n,a,i)}function i(t,e,n,o,s){let i=1/0,a=null;for(let c=o,u=o+s;c<u;c++){const o=r.intersectTri(t,e,n,c);o&&o.distance<i&&(a=o,i=o.distance)}return a}function a(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}})),o.register("1AcK3",(function(e,n){t(e.exports,"intersectTri",(()=>p));var r=o("hGT0Q");const s=new r.Vector3,i=new r.Vector3,a=new r.Vector3,c=new r.Vector2,u=new r.Vector2,l=new r.Vector2,d=new r.Vector3;function f(t,e,n,o,f,p,h){s.fromBufferAttribute(e,o),i.fromBufferAttribute(e,f),a.fromBufferAttribute(e,p);const x=function(t,e,n,o,s,i){let a;return a=i===r.BackSide?t.intersectTriangle(o,n,e,!0,s):t.intersectTriangle(e,n,o,i!==r.DoubleSide,s),null===a?null:{distance:t.origin.distanceTo(s),point:s.clone()}}(t,s,i,a,d,h);if(x){n&&(c.fromBufferAttribute(n,o),u.fromBufferAttribute(n,f),l.fromBufferAttribute(n,p),x.uv=r.Triangle.getUV(d,s,i,a,c,u,l,new r.Vector2));const t={a:o,b:f,c:p,normal:new r.Vector3,materialIndex:0};r.Triangle.getNormal(s,i,a,t.normal),x.face=t,x.faceIndex=o}return x}function p(t,e,n,r,o){const s=3*r,i=t.index.getX(s),a=t.index.getX(s+1),c=t.index.getX(s+2),u=f(n,t.attributes.position,t.attributes.uv,i,a,c,e);return u?(u.faceIndex=r,o&&o.push(u),u):null}})),o.register("a1MBZ",(function(e,n){t(e.exports,"setTriangle",(()=>r)),t(e.exports,"iterateOverTriangles",(()=>s));o("hGT0Q");function r(t,e,n,r){const o=t.a,s=t.b,i=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(e),c=n.getX(e+1),u=n.getX(e+2)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c),i.x=r.getX(u),i.y=r.getY(u),i.z=r.getZ(u)}function s(t,e,n,o,s,i,a){const c=n.index,u=n.attributes.position;for(let n=t,l=e+t;n<l;n++)if(r(a,3*n,c,u),a.needsUpdate=!0,o(a,n,s,i))return!0;return!1}})),o.register("6h74R",(function(e,n){t(e.exports,"PrimitivePool",(()=>r));class r{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}})),o.register("a0NSC",(function(e,n){function r(t,e){return 65535===e[t+15]}function o(t,e){return e[t+6]}function s(t,e){return e[t+14]}function i(t){return t+8}function a(t,e){return e[t+6]}function c(t,e){return e[t+7]}function u(t){return t}t(e.exports,"IS_LEAF",(()=>r)),t(e.exports,"OFFSET",(()=>o)),t(e.exports,"COUNT",(()=>s)),t(e.exports,"LEFT_NODE",(()=>i)),t(e.exports,"RIGHT_NODE",(()=>a)),t(e.exports,"SPLIT_AXIS",(()=>c)),t(e.exports,"BOUNDING_DATA_INDEX",(()=>u))})),o.register("apw2b",(function(e,n){t(e.exports,"MeshBVHVisualizer",(()=>c));var r=o("hGT0Q"),s=o("briuO");const i=new r.Box3;class a extends r.Object3D{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,o=0){super(),this.material=e,this.geometry=new r.BufferGeometry,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=o}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const o=this.depth-1,a=this.displayParents;let c=0;e.traverse(((t,e)=>{if(t===o||e)return c++,!0;a&&c++}),n);let u=0;const l=new Float32Array(24*c);let d,f;e.traverse(((t,e,n)=>{const r=t===o||e;if(r||a){s.arrayToBox(0,n,i);const{min:t,max:e}=i;for(let n=-1;n<=1;n+=2){const r=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const o=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const s=n<0?t.z:e.z;l[u+0]=r,l[u+1]=o,l[u+2]=s,u+=3}}}return r}}),n),f=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),d=l.length>65535?new Uint32Array(f.length*c):new Uint16Array(f.length*c);const p=f.length;for(let t=0;t<c;t++){const e=8*t,n=t*p;for(let t=0;t<p;t++)d[n+t]=e+f[t]}t.setIndex(new r.BufferAttribute(d,1,!1)),t.setAttribute("position",new r.BufferAttribute(l,3,!1)),this.visible=!0}}}class c extends r.Group{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new r.LineBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),o=new r.MeshBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1});o.color=n.color,this.edgeMaterial=n,this.meshMaterial=o,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let t=0;t<e;t++){if(t>=this._roots.length){const e=new a(this.mesh,this.edgeMaterial,this.depth,t);this.add(e),this._roots.push(e)}const e=this._roots[t];e.depth=this.depth,e.mesh=this.mesh,e.displayParents=this.displayParents,e.displayEdges=this.displayEdges,e.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new c(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}})),o.register("9iHAe",(function(e,n){t(e.exports,"getBVHExtremes",(()=>i)),t(e.exports,"estimateMemoryInBytes",(()=>a));o("hGT0Q");var r=o("kx6CP");o("briuO");function s(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function i(t){return t._roots.map(((e,n)=>function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse(((t,e,o,s,i)=>{const a=o[3]-o[0],c=o[4]-o[1],u=o[5]-o[2],l=2*(a*c+c*u+u*a);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(i,n.tris.min),n.tris.max=Math.max(i,n.tris.max),n.surfaceAreaScore+=l*r.TRIANGLE_INTERSECT_COST*i):(n.splits[s]++,n.surfaceAreaScore+=l*r.TRAVERSAL_COST)}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function a(t){const e=new Set,n=[t];let r=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;r+=s(e);const o=t[e];!o||"object"!=typeof o&&"function"!=typeof o?r+=s(o):/(Uint|Int|Float)(8|16|32)Array/.test(o.constructor.name)||o instanceof ArrayBuffer?r+=o.byteLength:n.push(o)}}}return r}})),o.register("24OKC",(function(e,n){t(e.exports,"acceleratedRaycast",(()=>l)),t(e.exports,"computeBoundsTree",(()=>d)),t(e.exports,"disposeBoundsTree",(()=>f));var r=o("hGT0Q"),s=o("2p372"),i=o("7xeSy");const a=new r.Ray,c=new r.Matrix4,u=r.Mesh.prototype.raycast;function l(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;c.copy(this.matrixWorld).invert(),a.copy(t.ray).applyMatrix4(c);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const r=s.convertRaycastIntersect(n.raycastFirst(a,this.material),this,t);r&&e.push(r)}else{const r=n.raycast(a,this.material);for(let n=0,o=r.length;n<o;n++){const o=s.convertRaycastIntersect(r[n],this,t);o&&e.push(o)}}}else u.call(this,t,e)}function d(t){return this.boundsTree=new i.MeshBVH(this,t),this.boundsTree}function f(){this.boundsTree=null}})),o.register("64srR",(function(e,n){t(e.exports,"MeshBVHUniformStruct",(()=>c));var r=o("hGT0Q"),s=o("bVjKl"),i=o("kx6CP"),a=o("a0NSC");class c{constructor(){this.autoDispose=!0,this.index=new s.UIntVertexAttributeTexture,this.position=new s.FloatVertexAttributeTexture,this.bvhBounds=new r.DataTexture,this.bvhContents=new r.DataTexture,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const o=t._roots;if(1!==o.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const s=o[0],c=new Uint16Array(s),u=new Uint32Array(s),l=new Float32Array(s),d=s.byteLength/i.BYTES_PER_NODE,f=2*Math.ceil(Math.sqrt(d/2)),p=new Float32Array(4*f*f),h=Math.ceil(Math.sqrt(d)),x=new Uint32Array(2*h*h);for(let t=0;t<d;t++){const e=t*i.BYTES_PER_NODE/4,n=2*e,r=a.BOUNDING_DATA_INDEX(e);for(let e=0;e<3;e++)p[8*t+0+e]=l[r+0+e],p[8*t+4+e]=l[r+3+e];if(a.IS_LEAF(n,c)){const r=a.COUNT(n,c),o=a.OFFSET(e,u),s=4294901760|r;x[2*t+0]=s,x[2*t+1]=o}else{const n=4*a.RIGHT_NODE(e,u)/i.BYTES_PER_NODE,r=a.SPLIT_AXIS(e,u);x[2*t+0]=r,x[2*t+1]=n}}e.image.data=p,e.image.width=f,e.image.height=f,e.format=r.RGBAFormat,e.type=r.FloatType,e.internalFormat="RGBA32F",e.minFilter=r.NearestFilter,e.magFilter=r.NearestFilter,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=x,n.image.width=h,n.image.height=h,n.format=r.RGIntegerFormat,n.type=r.UnsignedIntType,n.internalFormat="RG32UI",n.minFilter=r.NearestFilter,n.magFilter=r.NearestFilter,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}})),o.register("bVjKl",(function(e,n){t(e.exports,"UIntVertexAttributeTexture",(()=>a)),t(e.exports,"FloatVertexAttributeTexture",(()=>c));var r=o("hGT0Q");function s(t){switch(t){case 1:return r.RedIntegerFormat;case 2:return r.RGIntegerFormat;case 3:case 4:return r.RGBAIntegerFormat}}class i extends r.DataTexture{constructor(){super(),this.minFilter=r.NearestFilter,this.magFilter=r.NearestFilter,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,o=t.count;if(null!==e){if(n*o%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=o*n/e}const i=t.itemSize,a=t.count,c=t.normalized,u=t.array.constructor,l=u.BYTES_PER_ELEMENT;let d,f,p,h,x=this._forcedType,y=i;if(null===x)switch(u){case Float32Array:x=r.FloatType;break;case Uint8Array:case Uint16Array:case Uint32Array:x=r.UnsignedIntType;break;case Int8Array:case Int16Array:case Int32Array:x=r.IntType}let g=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(i);switch(x){case r.FloatType:p=1,f=function(t){switch(t){case 1:return r.RedFormat;case 2:return r.RGFormat;case 3:case 4:return r.RGBAFormat}}(i),c&&1===l?(h=u,g+="8",u===Uint8Array?d=r.UnsignedByteType:(d=r.ByteType,g+="_SNORM")):(h=Float32Array,g+="32F",d=r.FloatType);break;case r.IntType:g+=8*l+"I",p=c?Math.pow(2,8*u.BYTES_PER_ELEMENT-1):1,f=s(i),1===l?(h=Int8Array,d=r.ByteType):2===l?(h=Int16Array,d=r.ShortType):(h=Int32Array,d=r.IntType);break;case r.UnsignedIntType:g+=8*l+"UI",p=c?Math.pow(2,8*u.BYTES_PER_ELEMENT-1):1,f=s(i),1===l?(h=Uint8Array,d=r.UnsignedByteType):2===l?(h=Uint16Array,d=r.UnsignedShortType):(h=Uint32Array,d=r.UnsignedIntType)}3!==y||f!==r.RGBAFormat&&f!==r.RGBAIntegerFormat||(y=4);const m=Math.ceil(Math.sqrt(a)),T=new h(y*m*m);for(let e=0;e<a;e++){const n=y*e;T[n]=t.getX(e)/p,i>=2&&(T[n+1]=t.getY(e)/p),i>=3&&(T[n+2]=t.getZ(e)/p,4===y&&(T[n+3]=1)),i>=4&&(T[n+3]=t.getW(e)/p)}this.internalFormat=g,this.format=f,this.type=d,this.image.width=m,this.image.height=m,this.image.data=T,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=o}}class a extends i{constructor(){super(),this._forcedType=r.UnsignedIntType}}class c extends i{constructor(){super(),this._forcedType=r.FloatType}}})),o.register("bqsfV",(function(e,n){t(e.exports,"shaderStructs",(()=>r)),t(e.exports,"shaderIntersectFunction",(()=>o));const r="\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n",o="\n\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n"}));
//# sourceMappingURL=asyncGenerate.425ade06.js.map
