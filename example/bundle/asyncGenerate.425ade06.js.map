{"mappings":"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","sources":["src/core/MeshBVH.js","src/core/Constants.js","src/core/buildFunctions.js","src/core/MeshBVHNode.js","src/utils/ArrayBoxUtilities.js","src/core/castFunctions.js","src/math/OrientedBox.js","src/utils/GeometryRayIntersectUtilities.js","src/utils/ThreeRayIntersectUtilities.js","src/utils/TriangleUtilities.js","src/utils/PrimitivePool.js","src/core/nodeBufferFunctions.js","src/objects/MeshBVHVisualizer.js","src/debug/Debug.js","src/utils/ExtensionUtilities.js","src/gpu/MeshBVHUniformStruct.js","src/gpu/VertexAttributeTexture.js","src/gpu/shaderFunctions.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { SeparatingAxisTriangle } from '../math/SeparatingAxisTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new SeparatingAxisTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\n\t\t\t\t\tconst x = posArr[ index + 0 ];\n\t\t\t\t\tconst y = posArr[ index + 1 ];\n\t\t\t\t\tconst z = posArr[ index + 2 ];\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n\n// Deprecation\nconst originalRaycast = MeshBVH.prototype.raycast;\nMeshBVH.prototype.raycast = function ( ...args ) {\n\n\tif ( args[ 0 ].isMesh ) {\n\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.' );\n\t\tconst [\n\t\t\tmesh, raycaster, ray, intersects,\n\t\t] = args;\n\n\t\tconst results = originalRaycast.call( this, ray, mesh.material );\n\t\tresults.forEach( hit => {\n\n\t\t\thit = convertRaycastIntersect( hit, mesh, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn intersects;\n\n\t} else {\n\n\t\treturn originalRaycast.apply( this, args );\n\n\t}\n\n};\n\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\nMeshBVH.prototype.raycastFirst = function ( ...args ) {\n\n\tif ( args[ 0 ].isMesh ) {\n\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.' );\n\t\tconst [\n\t\t\tmesh, raycaster, ray,\n\t\t] = args;\n\n\t\treturn convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );\n\n\t} else {\n\n\t\treturn originalRaycastFirst.apply( this, args );\n\n\t}\n\n};\n\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\nMeshBVH.prototype.closestPointToPoint = function ( ...args ) {\n\n\n\tif ( args[ 0 ].isMesh ) {\n\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.' );\n\n\t\targs.unshift();\n\n\t\tconst target = args[ 1 ];\n\t\tconst result = {};\n\t\targs[ 1 ] = result;\n\n\t\toriginalClosestPointToPoint.apply( this, args );\n\n\t\tif ( target ) {\n\n\t\t\ttarget.copy( result.point );\n\n\t\t}\n\n\t\treturn result.distance;\n\n\t} else {\n\n\t\treturn originalClosestPointToPoint.apply( this, args );\n\n\t}\n\n};\n\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\nMeshBVH.prototype.closestPointToGeometry = function ( ...args ) {\n\n\tconst target1 = args[ 2 ];\n\tconst target2 = args[ 3 ];\n\tif ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {\n\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.' );\n\n\t\tconst result1 = {};\n\t\tconst result2 = {};\n\t\tconst geometryToBvh = args[ 1 ];\n\t\targs[ 2 ] = result1;\n\t\targs[ 3 ] = result2;\n\n\t\toriginalClosestPointToGeometry.apply( this, args );\n\n\t\tif ( target1 ) {\n\n\t\t\ttarget1.copy( result1.point );\n\n\t\t}\n\n\t\tif ( target2 ) {\n\n\t\t\ttarget2.copy( result2.point ).applyMatrix4( geometryToBvh );\n\n\t\t}\n\n\t\treturn result1.distance;\n\n\t} else {\n\n\t\treturn originalClosestPointToGeometry.apply( this, args );\n\n\t}\n\n};\n\nconst originalRefit = MeshBVH.prototype.refit;\nMeshBVH.prototype.refit = function ( ...args ) {\n\n\tconst nodeIndices = args[ 0 ];\n\tconst terminationIndices = args[ 1 ];\n\tif ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {\n\n\t\tconsole.warn( 'MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.' );\n\n\t\tconst newNodeIndices = new Set();\n\t\tterminationIndices.forEach( v => newNodeIndices.add( v ) );\n\t\tif ( nodeIndices ) {\n\n\t\t\tnodeIndices.forEach( v => newNodeIndices.add( v ) );\n\n\t\t}\n\n\t\toriginalRefit.call( this, newNodeIndices );\n\n\t} else {\n\n\t\toriginalRefit.apply( this, args );\n\n\t}\n\n};\n\n[\n\t'intersectsGeometry',\n\t'shapecast',\n\t'intersectsBox',\n\t'intersectsSphere',\n].forEach( name => {\n\n\tconst originalFunc = MeshBVH.prototype[ name ];\n\tMeshBVH.prototype[ name ] = function ( ...args ) {\n\n\t\tif ( args[ 0 ] === null || args[ 0 ].isMesh ) {\n\n\t\t\targs.shift();\n\t\t\tconsole.warn( `MeshBVH: The function signature for \"${ name }\" has changed and no longer takes Mesh. See docs for new signature.` );\n\n\t\t}\n\n\t\treturn originalFunc.apply( this, args );\n\n\t};\n\n} );\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n","import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst posArr = posAttr.array;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\t\tconst ai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\tconst bi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\tconst ci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tconst a = posArr[ ai + el ];\n\t\t\tconst b = posArr[ bi + el ];\n\t\t\tconst c = posArr[ ci + el ];\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copys bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { SeparatingAxisTriangle } from '../math/SeparatingAxisTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new SeparatingAxisTriangle();\n\tconst triangle2 = new SeparatingAxisTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n","import { Box3, Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { SeparatingAxisTriangle } from './SeparatingAxisTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox extends Box3 {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tsuper.set( min, max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new SeparatingAxisTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isSeparatingAxisTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\n\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\n\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\n\n\tvA.fromBufferAttribute( position, a );\n\tvB.fromBufferAttribute( position, b );\n\tvC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( ! target.uv ) target.uv = new Vector2();\n\t\ttarget.uv.copy( uv );\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootVisualizer extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.mesh = mesh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHVisualizer extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh, depth = 10 ) {\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tthis._roots.pop();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.depth = this.depth;\n\t\t\troot.mesh = this.mesh;\n\t\t\troot.displayParents = this.displayParents;\n\t\t\troot.displayEdges = this.displayEdges;\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tthis.position.copy( this.mesh.position );\n\t\tthis.rotation.copy( this.mesh.rotation );\n\t\tthis.scale.copy( this.mesh.scale );\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { MeshBVHVisualizer };\n","import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\tconst i0 = index.getX( i );\n\t\t\t\tconst i1 = index.getX( i + 1 );\n\t\t\t\tconst i2 = index.getX( i + 2 );\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n","import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/nodeBufferFunctions.js';\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.autoDispose = true;\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.index.updateFrom( geometry.index );\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","export const shaderStructs = /* glsl */`\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n`;\n\nexport const shaderIntersectFunction = /* glsl */`\n\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n`;\n"],"names":["$57c7281f11024a90$var$SKIP_GENERATION","Symbol","$57c7281f11024a90$var$aabb","$hGT0Q","Box3","$57c7281f11024a90$var$aabb2","$57c7281f11024a90$var$tempMatrix","Matrix4","$57c7281f11024a90$var$obb","$8QzBU","OrientedBox","$57c7281f11024a90$var$obb2","$57c7281f11024a90$var$temp","Vector3","$57c7281f11024a90$var$temp1","$57c7281f11024a90$var$temp2","$57c7281f11024a90$var$temp3","$57c7281f11024a90$var$temp4","$57c7281f11024a90$var$tempBox","$57c7281f11024a90$var$trianglePool","$6h74R","PrimitivePool","$8GBjY","SeparatingAxisTriangle","$57c7281f11024a90$export$9d614b3bc2c4eacf","bvh","options","isBufferGeometry","console","warn","serialize","arguments","cloneBuffers","undefined","geometry","rootData","_roots","indexAttribute","getIndex","result","roots","map","root","slice","index","array","data","deserialize","setIndex","newIndex","BufferAttribute","set","needsUpdate","Error","isInterleavedBufferAttribute","Object","assign","strategy","$kx6CP","CENTER","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","this","$luBM4","buildPackedTree","boundingBox","getBoundingBox","refit","nodeIndices","Array","isArray","Set","indexArr","posAttr","attributes","position","posArr","bufferOffset","offset","buffer","uint32Array","uint16Array","float32Array","stride","byteOffset","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","IS_LEAFNODE_FLAG","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","depth","isLeaf","count","BYTES_PER_NODE","splitAxis","raycast","ray","materialOrSide","FrontSide","intersects","isMaterial","isArrayMaterial","groups","side","materialSide","materialIndex","startCount","$e1Md5","setBuffer","clearBuffer","j","jl","face","raycastFirst","closestResult","distance","intersectsGeometry","otherGeometry","geomToMesh","shapecast","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","triangle","getPrimitive","originalIntersectsRange","nodeIndex","$a1MBZ","iterateOverTriangles","releasePrimitive","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","copy","invert","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","setTriangle","a","applyMatrix4","b","c","i1","l1","originalIntersectsRanges","box","intersectsBox","nodeIndex1","nodeIndex2","boxToMesh","min","max","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","matrix","distanceToBox","score","boundsTree","otherOffset","otherCount","dist","distanceToTriangle","point","clone","faceIndex","sub","closestPointToPoint","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","triIndex","distSq","Math","sqrt","makeEmpty","forEach","$briuO","arrayToBox","union","$57c7281f11024a90$var$originalRaycast","prototype","args","isMesh","mesh","raycaster","call","material","hit","$2p372","convertRaycastIntersect","push","apply","$57c7281f11024a90$var$originalRaycastFirst","$57c7281f11024a90$var$originalClosestPointToPoint","unshift","$57c7281f11024a90$var$originalClosestPointToGeometry","isVector3","result1","result2","$57c7281f11024a90$var$originalRefit","terminationIndices","newNodeIndices","v","add","name","originalFunc","shift","$ef2c0759b6da6d97$export$91c2158bc24c63d4","$ef2c0759b6da6d97$export$d3bfe4097a2a8542","$ef2c0759b6da6d97$export$2b2cc3fb4f03d723","$ef2c0759b6da6d97$export$34b5498ca69d033","$ef2c0759b6da6d97$export$a26e00882057cd76","$ef2c0759b6da6d97$export$82ad94f0a038b67a","$ef2c0759b6da6d97$export$22e1995328fd3cd9","$ef2c0759b6da6d97$export$f4b101accf1b23d1","$ef2c0759b6da6d97$export$a08e7d18fbc53be5","$ef2c0759b6da6d97$export$661fddb62bfe0e42","$ef2c0759b6da6d97$export$859129fb5c8f4dc1","pow","$fa59b37e24448501$var$getBounds","triangleBounds","centroidTarget","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","$fa59b37e24448501$var$BIN_COUNT","$fa59b37e24448501$var$binsSort","candidate","$fa59b37e24448501$var$sahBins","fill","bounds","rightCacheBounds","leftCacheBounds","$fa59b37e24448501$var$leftBounds","$fa59b37e24448501$export$9896244d8c99a4d0","geo","triggerProgress","trianglesProcessed","totalTriangles","splitNode","node","centroidBoundingData","reachedMaxDepth","split","nodeBoundingData","axis","getLongestEdgeIndex","AVERAGE","avg","$fa59b37e24448501$var$getAverage","SAH","rootSurfaceArea","computeSurfaceArea","bestCost","TRIANGLE_INTERSECT_COST","cStart","cEnd","axisLeft","binWidth","truncatedBins","bin","d","expandByTriangleBounds","sort","splitCount","bi","splice","c1","center","bi1","leftCount","rightCount","leftBounds","rightBounds","leftProb","rightProb","cost","TRAVERSAL_COST","binIndex","lastBin","copyBounds","nextBin","unionBounds","binCount","$fa59b37e24448501$var$getOptimalSplit","boundingData","splitOffset","axisOffset","t0","t1","t2","$fa59b37e24448501$var$partition","indexArray","$iXQTr","MeshBVHNode","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","vertexCount","BufferConstructor","ArrayBuffer","$fa59b37e24448501$var$ensureIndex","fullBounds","triCount","tri3","tri6","ai","ci","el","halfExtents","el2","abs","FLOAT32_EPSILON","$fa59b37e24448501$var$computeTriangleBounds","ranges","rangeBoundaries","group","start","sortedBoundaries","from","values","$fa59b37e24448501$var$getRootIndexRanges","range","$fa59b37e24448501$var$getCentroidBounds","$fa59b37e24448501$export$e63bca57f220b8e3","packedRoots","nodeCount","countNodes","populateBuffer","stride4Offset","stride2Offset","nextUnusedPointer","$dce6c42c827cf3d0$export$6f473cc5f89b0a1c","$8540903f1e3bfcc0$export$40b9a5e446bf11e0","nodeIndex32","$8540903f1e3bfcc0$export$dcdc414399b99746","splitDimIdx","splitDist","$8540903f1e3bfcc0$export$14b050a767b4a3a7","source","$8540903f1e3bfcc0$export$a8a7063dce01a911","aVal","bVal","d3","$8540903f1e3bfcc0$export$c989e53c4b24c2f5","startIndex","tCenter","tHalf","tMin","tMax","$8540903f1e3bfcc0$export$dbf4320364dc239e","d0","d1","d2","$a3668e38fb87ebfd$var$boundingBox","$a3668e38fb87ebfd$var$boxIntersection","$a3668e38fb87ebfd$var$xyzFields","$a3668e38fb87ebfd$export$630e89aab3ddc1d6","nodeIndex16","$a3668e38fb87ebfd$var$_float32Array","$a3668e38fb87ebfd$var$_uint16Array","$a3668e38fb87ebfd$var$_uint32Array","$a0NSC","IS_LEAF","OFFSET","COUNT","intersectTris","leftIndex","LEFT_NODE","$a3668e38fb87ebfd$var$intersectRay","rightIndex","RIGHT_NODE","$a3668e38fb87ebfd$export$1fa457bc72ef1a2a","intersectClosestTri","SPLIT_AXIS","xyzAxis","leftToRight","direction","c2","c1Result","c2Result","$a3668e38fb87ebfd$export$963c78622ed2c172","_box1","_box2","boxStack","boxPool","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","BOUNDING_DATA_INDEX","score1","score2","box1","box2","temp","c1Intersection","c1StopTraversal","CONTAINED","c2Intersection","c2StopTraversal","pop","$a3668e38fb87ebfd$export$b2f96b0abaf94e0a","invertedMat","obb","obb2","cachedObb","thisGeometry","thisIndex","thisPos","intersectBox","$a3668e38fb87ebfd$var$bufferStack","$a3668e38fb87ebfd$var$_prevBuffer","$a3668e38fb87ebfd$export$8e35cea4592af4e6","$a3668e38fb87ebfd$export$abb0b37bc9255c0e","$670ecd8687d0d335$export$4ccecd8ac6ee0e58","super","isOrientedBox","invMatrix","points","satAxes","satBounds","$lqzhf","SeparatingAxisBounds","alignedSatBounds","other","update","minVec","sb","pi","subVectors","setFromPoints","setFromPointsField","aabbBounds","isSeparated","setFromBox","saTri","pointsArr","cachedSatBounds","cachedSatBounds2","cachedAxis","isSeparatingAxisTriangle","sa","triSatBounds","triSatAxes","sa1","sa2","crossVectors","distanceToPoint","distanceTo","xyzFields","segments1","Line3","segments2","point1","point2","threshold","getCenter","threshold2","p","nextIndex","nextIndex2","p1","p2","f1","f2","f3","line2","$b6MQC","closestPointsSegmentToSegment","$1c0054ac420f420d$export$6f0a8fc5d2775a51","intersections","$1AcK3","intersectTri","$1c0054ac420f420d$export$4331f2604b0bca4","res","intersection","$1c0054ac420f420d$export$adb106eed99e8cd8","object","matrixWorld","origin","near","far","$1273097a11ba7c4e$var$vA","$1273097a11ba7c4e$var$vB","$1273097a11ba7c4e$var$vC","$1273097a11ba7c4e$var$uvA","Vector2","$1273097a11ba7c4e$var$uvB","$1273097a11ba7c4e$var$uvC","$1273097a11ba7c4e$var$intersectionPoint","$1273097a11ba7c4e$var$checkBufferGeometryIntersection","uv","fromBufferAttribute","pA","pB","pC","intersect","BackSide","intersectTriangle","DoubleSide","$1273097a11ba7c4e$var$checkIntersection","Triangle","getUV","normal","getNormal","$1273097a11ba7c4e$export$1a557053019a130b","triOffset","getX","$74cfb4ac68fe9dd6$export$32f7fa781964ae30","ta","tb","tc","i0","getY","getZ","$74cfb4ac68fe9dd6$export$be1391b7aa79c0f6","intersectsTriangleFunc","$4919d203a265b307$export$bf300c504651112a","getNewPrimitive","_getNewPrimitive","_primitives","primitives","primitive","$74a098982759de7d$export$bc7cbaf27fbe938e","n16","$74a098982759de7d$export$3231e969238304f3","n32","$74a098982759de7d$export$d61684373eacdf61","$74a098982759de7d$export$7a68bc00425859d","$74a098982759de7d$export$4f44f52d9f75fa31","$74a098982759de7d$export$b43717b3ca95505","$74a098982759de7d$export$b5b7e27a1440579d","$794516839af19c98$var$boundingBox","$794516839af19c98$var$MeshBVHRootVisualizer","Object3D","displayEdges","isLineSegments","isLine","BufferGeometry","displayParents","_group","dispose","visible","targetDepth","boundsCount","posIndex","positionArray","indices","terminate","xVal","yVal","zVal","Uint8Array","indexLength","posOffset","indexOffset","setAttribute","$794516839af19c98$export$5ead38ed5c75a1c8","Group","color","edgeMaterial","opacity","meshMaterial","LineBasicMaterial","transparent","depthWrite","MeshBasicMaterial","totalRoots","updateMatrixWorld","rotation","scale","children","$6c579a3f1ca4eadc$var$getPrimitiveSize","$6c579a3f1ca4eadc$export$de5f6c317656a6ce","leafNodeCount","tris","splits","surfaceAreaScore","offsetOrSplit","l0","surfaceArea","$6c579a3f1ca4eadc$var$getRootExtremes","$6c579a3f1ca4eadc$export$d677314be3f8df27","obj","traversed","stack","bytes","curr","key","hasOwnProperty","value","test","constructor","$1833528e4d0ebf15$var$ray","Ray","$1833528e4d0ebf15$var$tmpInverseMatrix","$1833528e4d0ebf15$var$origMeshRaycastFunc","Mesh","$1833528e4d0ebf15$export$a0dc2935489c814a","firstHitOnly","hits","$1833528e4d0ebf15$export$749bba8a65fa6d70","$7xeSy","MeshBVH","$1833528e4d0ebf15$export$e0a981a7a32ddba4","$46b92f08e5e447d2$export$4dc20da53fccce35","autoDispose","$bVjKl","UIntVertexAttributeTexture","FloatVertexAttributeTexture","bvhBounds","DataTexture","bvhContents","overrideItemSize","updateFrom","boundsTexture","contentsTexture","boundsDimension","ceil","boundsArray","contentsDimension","contentsArray","boundsIndex","mergedLeafCount","image","width","height","format","RGBAFormat","type","FloatType","internalFormat","minFilter","NearestFilter","magFilter","generateMipmaps","RGIntegerFormat","UnsignedIntType","$46b92f08e5e447d2$var$bvhToTextures","$8ae455d64fd40da4$var$countToIntFormat","RedIntegerFormat","RGBAIntegerFormat","$8ae455d64fd40da4$export$2ba8de89bc26b001","_forcedType","attr","originalItemSize","itemSize","originalCount","normalized","originalBufferCons","byteCount","BYTES_PER_ELEMENT","normalizeValue","targetBufferCons","targetType","finalStride","Int8Array","Int16Array","Int32Array","IntType","$8ae455d64fd40da4$var$countToStringFormat","RedFormat","RGFormat","$8ae455d64fd40da4$var$countToFormat","UnsignedByteType","ByteType","ShortType","UnsignedShortType","dimension","dataArray","ii","getW","$8ae455d64fd40da4$export$de036370a093ef","$8ae455d64fd40da4$export$5444fd0f1815741f","$85180a6abfecb4f8$export$1b1b39b9861ca334"],"version":3,"file":"asyncGenerate.425ade06.js.map"}